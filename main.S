# 5. Инвертирует все нечетные числа в памяти
.text
_start:
    # ========== ФАЗА 1: ИНВЕРТИРОВАНИЕ НЕЧЁТНЫХ ЧИСЕЛ ==========

    # Инициализация
    addi x11, x0, 0        # x11 = базовый адрес массива (0)
    addi x5,  x0, 0        # x5  = индекс i = 0
    addi x6,  x11, 0       # x6  = текущий адрес = 0
    addi x14, x0, 1        # x14 = 1 (для проверки на нечётность)

invert_loop:
    # Загружаем текущее число из памяти
    lw   x8, 0(x6)         # x8 = mem[addr]

    # Проверка на нечётность через младший бит:
    # x9 = x8 | 1
    # x12 = x9 - x8
    # если x8 чётное:  x9 = x8 + 1, x12 = 1
    # если x8 нечётное: x9 = x8,     x12 = 0
    or   x9,  x8, x14      # x9 = x8 | 1
    sub  x12, x9, x8       # x12 = x9 - x8

    # Если x12 != 0 → число чётное → пропускаем инвертирование
    bne  x12, x0, skip_invert

    # Число нечётное → инвертируем: ~x = -1 - x
    addi x12, x0, -1       # x12 = -1 (0xFFFFFFFF)
    sub  x8,  x12, x8      # x8 = -1 - x8 = ~x8
    sw   x8,  0(x6)        # сохраняем обратно в память

skip_invert:
    # Переходим к следующему слову
    addi x6, x6, 4         # addr += 4 байта (следующее слово)
    addi x5, x5, 1         # i++

    # Проверяем, что ещё не обработали все 32 слова
    addi x13, x0, 32       # x13 = 32
    sltu x13, x5, x13      # x13 = 1, если i < 32
    bne  x13, x0, invert_loop

    # ========== ФАЗА 2: ВЫВОД ВСЕХ ЭЛЕМЕНТОВ ЧЕРЕЗ a0 ==========

    addi x5, x0, 0         # x5 = 0
    addi x6, x11, 0        # x6 = 0

output_array:
    lw   x10, 0(x6)        # a0 = mem[addr]

    addi x6, x6, 4         # addr += 4
    addi x5, x5, 1         # i++

    addi x13, x0, 32       # x13 = 32
    sltu x13, x5, x13      # x13 = 1, если i < 32
    bne  x13, x0, output_array

    # ========== ЗАВЕРШЕНИЕ: ЗАЦИКЛИТЬСЯ ==========
end:
    beq  x0, x0, end       # бесконечный цикл, PC остаётся в допустимой области